打家劫舍 但這題對空間有限制

```cpp

class Solution {
public:
    long long maximumTotalDamage(vector<int>& power) {
        unordered_map<int, long long> freq;
        for (int p : power) freq[p]++;
        vector<int> keys;
        for (auto& [k, _] : freq) keys.push_back(k);
        sort(keys.begin(), keys.end());
        int n = keys.size();
        vector<long long> dp(n);
        dp[0] = freq[keys[0]] * keys[0];

        for (int i = 1; i < n; i++) {
            
            long long take = freq[keys[i]] * keys[i];
            // 1. 定義我們的目標值
            //    我們要尋找的是所有傷害值小於或等於 `target` 的法術中，位置最靠後的那一個。
            int target = keys[i] - 3;

            // 2. 使用 upper_bound 尋找
            //    它會在 [keys[0]...keys[i-1]] 範圍內，找到第一個 *大於* `target` 的元素。
            //    舉例：如果 keys = [2, 3, 5, 8], target = 4, upper_bound 會找到 5。
            auto it = std::upper_bound(keys.begin(), keys.begin() + i, target);

            // 3. 取得該元素的索引
            //    it - keys.begin() 可以計算出這個 iterator 的索引。
            int greater_idx = it - keys.begin();

            // 4. 往前推一個位置
            //    既然 greater_idx 是第一個 *大於* target 的位置，
            //    那麼它的前一個位置 (greater_idx - 1)，就必然是 *小於或等於* target 的最後一個位置。
            //    這正是我們想要的！
            int prev_idx = greater_idx - 1;

            // 後續邏輯不變
            if (prev_idx >= 0) { // 這裡要檢查 prev_idx 是否有效 (例如，如果所有數字都比 target 大，prev_idx 會是 -1)
                take += dp[prev_idx];
            }
            dp[i] = max(dp[i - 1], take);
        }
        return dp[n - 1];
    }
};

```
