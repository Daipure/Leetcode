數學難題
將題目轉換為target 是否能表示為 k 個 2 的冪次方的和？
要滿足以下條件
1. 代表 target >= k 因為2 的冪次方最小為1 1*=k
2. k>= popcount(target) 因為popcount(target)為組成target的最小2的密次方大

```cpp
class Solution {
public:
    int makeTheIntegerZero(int num1, int num2) {
                // 邊界情況：如果 num1 已經是 0，則需要 0 次操作。
        if (num1 == 0) {
            return 0;
        }

        // 我們從 k = 1 開始迭代，尋找可能的最小操作次數 k。
        // 迴圈上限設為 100 是一個安全的選擇，因為 k 不會變得非常大。
        for (int k = 1; k < 100; ++k) {
            
            // 對於每一次假設的操作次數 k，計算目標值 target。
            // target = num1 - k * num2
            // 這裡使用 long long 是為了防止 k * num2 的計算結果溢位。
            long long target = (long long)num1 - (long long)k * num2;

            // 問題轉化為：target 是否能表示為 k 個 2 的冪次方的和？
            // 這需要滿足兩個條件：
            // 1. 值的下限：target 必須大於等於 k。
            //    (因為 k 個 2 的冪次方最小的和是 k 個 1，即 k)
            // 2. 位元數的上限：target 的二進位中 1 的個數必須小於等於 k。
            //    (因為 popcount(target) 是構成 target 所需的最少冪次方數量)
            if (target >= k && popcount((unsigned long long)target) <= k) {
                // 由於 k 是從 1 開始遞增的，我們找到的第一個滿足條件的 k 就是最小值。
                return k;
            }
        }

        // 如果迴圈結束後仍未找到滿足條件的 k，則表示無解。
        return -1;
    }
};
```
