題目是要讓每個朋友對都能溝通
所以我們要找出不同溝通的朋友對 把他們加入集合
並且去統計他們中最多人用的語言
讓剩下的人學會 這樣會是最少的 也是效益最大的
不同語言也可能最少 但效益不會是最大

所以Return set count - 最多人會的語言的次數

```cpp
class Solution {
public:
    int minimumTeachings(int n, vector<vector<int>>& languages, vector<vector<int>>& friendships) {
        
        // languages 是 0-indexed，但 friendships 裡的使用者是 1-indexed
        // 先將所有人的語言轉成 set，方便後面快速查找
        vector<unordered_set<int>> user_languages(languages.size());
        for (int i = 0; i < languages.size(); ++i) {
            for (int lang : languages[i]) {
                user_languages[i].insert(lang);
            }
        }

        // 步驟 1：找出所有無法溝通的人
        unordered_set<int> uncommunicative_users;
        for (const auto& friendship : friendships) {
            int u1 = friendship[0] - 1; // 修正 1: 索引 -1
            int u2 = friendship[1] - 1; // 修正 1: 索引 -1

            bool can_communicate = false;
            for (int lang1 : user_languages[u1]) {
                if (user_languages[u2].count(lang1)) {
                    can_communicate = true;
                    break;
                }
            }

            if (!can_communicate) {
                uncommunicative_users.insert(u1 + 1); // 存回 1-based ID
                uncommunicative_users.insert(u2 + 1); // 存回 1-based ID
            }
        }
        
        if (uncommunicative_users.empty()) {
            return 0;
        }

        // 步驟 2：統計這些人中，哪個語言最普遍
        unordered_map<int, int> lang_count;
        for (int user_id : uncommunicative_users) {
            // 修正 1: 存取 languages 時要 -1
            for (int lang : languages[user_id - 1]) {
                lang_count[lang]++;
            }
        }

        // 步驟 3：找出最多人會的那個語言的「人數」
        int max_speakers = 0;
        for (auto const& [lang, count] : lang_count) {
            if (count > max_speakers) {
                max_speakers = count;
            }
        }

        // 步驟 4：總人數 - 已經會的人數 = 需要教的人數
        return uncommunicative_users.size() - max_speakers;
    }
};

```
