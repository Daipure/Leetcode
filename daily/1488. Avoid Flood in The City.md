 演算法核心策略：
 1. 使用 map 記錄每個已滿湖泊的下雨日期。
 2. 使用 set 收集所有可用的抽乾日。
 3. 當洪水危機發生時，使用 upper_bound 在 set 中尋找「最早的、可行的」抽乾日來解決。

```cpp

class Solution {
public:
    vector<int> avoidFlood(vector<int>& rains) {
        // 演算法核心策略：
        // 1. 使用 map 記錄每個已滿湖泊的下雨日期。
        // 2. 使用 set 收集所有可用的抽乾日。
        // 3. 當洪水危機發生時，使用 upper_bound 在 set 中尋找「最早的、可行的」抽乾日來解決。

        int n = rains.size();
        vector<int> result(n, 1); // 儲存最終結果，預設抽乾日填 1

        // 記錄已滿湖泊及其對應的下雨日期 {湖泊ID -> 日期索引}
        unordered_map<int, int> full_lakes; 
        
        // 按日期順序存放所有可用的抽乾日
        set<int> dry_days;

        for (int i = 0; i < n; ++i) {
            int current_lake = rains[i];

            if (current_lake == 0) {
                // Case 1: 今天是抽乾日，收集起來以備不時之需
                dry_days.insert(i);
            } else {
                // Case 2: 今天是下雨日
                result[i] = -1; // 下雨天固定為 -1

                // 檢查這個湖泊之前是否已經滿了
                if (full_lakes.count(current_lake)) {
                    // 洪水危機！湖泊已滿，必須找到一天來抽乾它
                    int prev_rain_day = full_lakes[current_lake];

                    // 尋找一個在 prev_rain_day 之後的、最早的可用抽乾日
                    auto it = dry_days.upper_bound(prev_rain_day);

                    if (it == dry_days.end()) {
                        // 如果找不到任何有效的抽乾日，洪水無法避免
                        return {};
                    }

                    // 找到了可行的抽乾日
                    int day_to_use = *it;
                    result[day_to_use] = current_lake; // 更新日誌：在那天抽乾這個湖泊
                    dry_days.erase(it);                // 這個抽乾日已經被用掉了
                    full_lakes.erase(current_lake);    // 湖泊被抽乾了，從已滿清單中移除
                }
                
                // 無論如何，今天下雨了，所以更新 (或新增) 該湖泊的下雨日期為今天
                full_lakes[current_lake] = i;
            }
        }
        return result;
    }
};
```
