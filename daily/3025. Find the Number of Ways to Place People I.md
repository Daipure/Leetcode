暴力找尋合乎規則的節點 因為測資說小於五十筆

'''cpp
class Solution {
public:
    int numberOfPairs(vector<vector<int>>& points) {
        int n = points.size();
        int count = 0;

        // 第一層迴圈：固定點 A
        for (int i = 0; i < n; ++i) {
            int ax = points[i][0];
            int ay = points[i][1];

            // 第二層迴圈：固定點 B
            for (int j = 0; j < n; ++j) {
                // A 和 B 不能是同一個點
                if (i == j) {
                    continue;
                }

                int bx = points[j][0];
                int by = points[j][1];

                // 【修正點】檢查條件 1：A 必須在 B 的左上方
                // 如果不滿足，就直接跳過這個點 B，繼續找下一個
                if (ax > bx || ay < by) { // 注意：這裡是 ax > bx 或 ay < by
                    continue;
                }
                
                // 到這裡，說明 (A, B) 滿足了左上關係，是一個候選點對
                // 現在檢查條件 2：它們之間是否為空

                bool is_empty = true; // 【修正點】先假設是空的

                // 第三層迴圈：檢查所有其他的點 k (C)
                for (int k = 0; k < n; ++k) {
                    if (k == i || k == j) {
                        continue;
                    }

                    int kx = points[k][0];
                    int ky = points[k][1];
                    
                    // 【修正點】使用正確的語法和邏輯判斷 k 是否在矩形內
                    if ((ax <= kx && kx <= bx) && (by <= ky && ky <= ay)) {
                        is_empty = false; // 發現了障礙點，推翻假設
                        break;            // 立刻停止檢查，跳出 k 迴圈
                    }
                }

                // 【修正點】在 k 迴圈結束後，才根據 is_empty 的最終結果來計數
                if (is_empty) {
                    count++; // 如果假設從未被推翻，說明這是一對合法的點對
                }
            }
        }
        return count;
    }
};

'''
