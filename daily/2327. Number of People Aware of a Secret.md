暫時想不出來

```cpp

class Solution {
public:
    int peopleAwareOfSecret(int n, int delay, int forget) {
        // 定義 MOD
        long long MOD = 1e9 + 7;

        // dp[i] = 第 i 天 "新知道" 秘密的人數
        // 使用 long long 來儲存 dp 值，避免中間累加過程溢位
        vector<long long> dp(n + 1, 0);

        // Base Case: 第 1 天有 1 個新人
        dp[1] = 1;

        // sharing_sum: 滑動窗口，代表當前 "能分享秘密" 的總人數
        // (即 dp[i-forget+1] 到 dp[i-delay] 的總和)
        long long sharing_sum = 0;

        // total_known: 滑動窗口，代表 "還記得秘密" 的總人數
        // (即 dp[i-forget+1] 到 dp[i] 的總和)。這就是我們最終要的答案。
        // 我們從第 1 天開始動態維護這個總和。
        long long total_known = 1; // 從 dp[1] 開始

        // 從第 2 天開始迭代到第 n 天
        for (int i = 2; i <= n; ++i) {
            
            // 1. 更新 sharing_sum (滑動窗口)
            // 1a. 加入新 sharer：第 (i - delay) 天的人，今天開始分享了
            if (i - delay >= 1) {
                sharing_sum = (sharing_sum + dp[i - delay]) % MOD;
            }
            // 1b. 移除舊 sharer：第 (i - forget) 天的人，今天忘記了 (所以也停止分享)
            if (i - forget >= 1) {
                // 處理 modulo 減法，加上 MOD 確保結果為正
                sharing_sum = (sharing_sum - dp[i - forget] + MOD) % MOD;
            }
            
            // 2. 計算今天的 dp[i]
            // 今天的新增人數 = 當前能分享的總人數
            dp[i] = sharing_sum;

            // 3. 更新 total_known (答案窗口)
            // 3a. 加入今天的新人
            total_known = (total_known + dp[i]) % MOD;
            // 3b. 扣除今天剛忘記的人 (他們離開了 "已知" 的行列)
            if (i - forget >= 1) {
                total_known = (total_known - dp[i - forget] + MOD) % MOD;
            }
        }

        // 當迴圈跑到 i = n 時，total_known 正好代表了
        // dp[n-forget+1] 到 dp[n] 的總和
        return (int)total_known;
    }
};

```
