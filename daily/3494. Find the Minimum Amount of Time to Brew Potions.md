
### 📝 核心筆記：最短煉藥時間問題 (火車調度模型)

#### 1\. 問題本質

此問題的目標是找出完成所有藥水的**最短總時間**。這不是一個簡單的流水線問題，而是一個**排程優化問題**。關鍵在於，我們可以**策略性地延遲**後面藥水的起始時間，以避開前一瓶藥水造成的「交通堵塞」，從而達成全局最優。

#### 2\. 核心思想：計算「最小安全換線間隔 (maxDelay)」

想像巫師是車站，藥水是火車。當一列慢車 (mana大) 在軌道上時，我們不能立刻派出下一列快車 (mana小)，否則快車會在某個車站追撞上慢車，造成空等。

`maxDelay` 就是為了讓下一班列車安全出發，我們必須等待的**最小發車間隔時間**。這個時間由**最慢、最容易造成瓶頸的那個車站 (巫師)** 決定。

#### 3\. 演算法步驟

1.  **[預處理] 計算前綴和 (Prefix Sum)**：

      * 建立 `prefixSkill` 陣列，`prefixSkill[i]` 儲存從 `skill[0]` 到 `skill[i]` 的總和。
      * **目的**：讓我們能用 O(1) 的時間快速查詢「一瓶藥水通過前 `i` 位巫師」所需的總技能點。

2.  **[初始化] 設定起始點**：

      * `startTime` 初始為 0，代表第一瓶藥水總是可以從 `t=0` 開始。

3.  **[迭代] 計算每瓶藥水的最佳起始時間**：

      * 從第二瓶藥水 (`j=1`) 開始，依序計算每一瓶與前一瓶的 `maxDelay`。
      * **如何計算 `maxDelay`**：
          * 對於**每一位巫師 `i`**，計算一個局部的 `delay`。
          * `delay` = (前一瓶藥水佔用完巫師 `i` 的時間) - (這一瓶藥水抵達巫師 `i` 的時間)。
          * `maxDelay` 就是所有巫師算出的 `delay` 中的**最大值**。
      * **更新起始時間**：`startTime += maxDelay`。這個新的 `startTime` 就是下一瓶藥水的最佳出發時間。

4.  **[計算結果]**

      * 總時間 = 最後一瓶藥水的最佳起始時間 (`startTime`) + 它自己完整跑完流水線所需的時間。

-----

### 💻 程式碼詳解 (附優化註釋)

```cpp
#include <vector>
#include <algorithm> // 為了使用 std::max

class Solution {
public:
    long long minTime(std::vector<int>& skill, std::vector<int>& mana) {
        int n = skill.size();
        int m = mana.size();

        // [預處理] 步驟 1: 計算 skill 的前綴和陣列。
        // 使用 long long 型別來儲存前綴和，以防止累加過程中發生整數溢位。
        std::vector<long long> prefixSkill(n, 0);
        prefixSkill[0] = skill[0];
        for (int i = 1; i < n; ++i) {
            prefixSkill[i] = prefixSkill[i - 1] + skill[i];
        }

        // [初始化] 步驟 2: 設定起始時間。
        // startTime 代表「下一瓶」藥水可以開始的最佳時間點。第一瓶藥水永遠從 t=0 開始。
        long long startTime = 0;

        // [迭代] 步驟 3: 從第二瓶藥水 (j=1) 開始，計算它與前一瓶之間的最小安全間隔。
        for (int j = 1; j < m; ++j) {
            // maxDelay: 為了讓藥水 j 不與藥水 j-1 衝突，所需等待的「最小安全發車間隔」。
            long long maxDelay = 0;
            
            // 遍歷所有巫師 i，找出造成最大瓶頸 (delay) 的那一位。
            for (int i = 0; i < n; ++i) {
                // prevPrefix: 藥水 j 要抵達巫師 i 之前，所經過路徑的 skill 總和。
                // 這是個邊界處理：對第一位巫師(i=0)來說，他之前沒有路徑，所以是 0。
                long long prevPrefix = (i == 0) ? 0 : prefixSkill[i - 1]; 
                
                // delay: 從巫師 i 的視角，計算出的必要延遲時間。
                // T_busy = mana[j-1] * prefixSkill[i]  (巫師 i 會因前一瓶藥水忙到什麼時候)
                // T_arrival = mana[j] * prevPrefix      (這一瓶藥水會以多快的速度抵達巫師 i)
                long long delay = (long long)mana[j - 1] * prefixSkill[i] - (long long)mana[j] * prevPrefix;

                // 我們必須滿足所有巫師中最嚴格的要求，所以取最大值。
                maxDelay = std::max(maxDelay, delay);
            }
            
            // 將這個安全間隔累加到 startTime，得到下一瓶藥水的最佳出發時間。
            startTime += maxDelay;
        }

        // [計算結果] 步驟 4: 總時間 = 最後一瓶藥水的起始時間 + 它自己流經所有巫師的時間。
        return startTime + (long long)mana[m - 1] * prefixSkill[n - 1];
    }
};
```

```
