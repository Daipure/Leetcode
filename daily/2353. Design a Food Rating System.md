利用set的特性 會自動排序最小的 將分數變成負船進去
每個菜系一個排行榜
用兩個map 一個用來記錄食物的舊分數
一個用來更新排行榜 (要知道舊分數才能刪除)


```cpp

class FoodRatings {
public:
    struct FoodInfo {
        int rating;
        string cuisine;
    };

    // 一個 unordered_map 來快速查找食物資訊
    unordered_map<string, FoodInfo> food_map;

    // 一個 unordered_map 來管理各菜系的排行榜 (每個菜系 (cuisine) 都對應一個自己的 set)
    unordered_map<string, set<pair<int, string>>> cuisine_ratings;

    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {
        // 使用數據結構儲存
        int n = foods.size();
        for (int i = 0; i < n; i++) {
            food_map[foods[i]] = {ratings[i], cuisines[i]};
            
            // 【修正 1】使用 .insert() 將 pair 插入 set
            cuisine_ratings[cuisines[i]].insert({-ratings[i], foods[i]});
        }
    }
    
    void changeRating(string food, int newRating) {
        // 更改某個食物的分數

        // 1. 取得舊資訊
        FoodInfo &info = food_map[food];
        
        // 【修正 2】加上分號 ;
        int old_rating = info.rating;
        string cuisine = info.cuisine;

        // 2. 從排行榜移除舊紀錄
        // 【修正 3】使用正確的變數名稱 cuisine
        cuisine_ratings[cuisine].erase({-old_rating, food});

        // 3. 更新基礎資訊裡的評分
        info.rating = newRating;
        
        // 4. 將新紀錄加入排行榜
        cuisine_ratings[cuisine].insert({-newRating, food});
    }
    
    string highestRated(string cuisine) {
        // 回傳食譜中評分最高的
        // 同分回傳字母小的

        // 直接回傳對應 set 的第一個元素的食物名稱即可
        return cuisine_ratings[cuisine].begin()->second;
    }
};
```
