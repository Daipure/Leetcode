使用二分搜尋法減少搜尋時間
向上取整: a+b-/b
當找到第一個大於等於 (lower_bound)
distance: 迭代器的距離
```cpp


class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {
        // n個spell m個potion
        // 乘積大於等於 success
        // 回傳每輪成功的數量
        // sort potions 每輪如果找到一個是大於等於success 那剩下也會

        sort(potions.begin(),potions.end());
        vector<int>res;

        // 要找到 spell * potions >= sucess 轉換為
        // 找到 potion >= sucess/spell
        for(int spell: spells){
            long long min_potions = (success+spell-1)/spell;
            auto it = lower_bound(potions.begin(),potions.end(),min_potions);
            int count = distance(it,potions.end());
            res.push_back(count);
        }
        return res;
    }
};
```
