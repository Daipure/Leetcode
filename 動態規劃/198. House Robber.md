選擇 1：【不偷】第 i 間房子
如果我們決定 不偷 第 i 間，那麼我們身上能帶走的錢，就是截至前一間 (i-1) 為止，我們已經能拿到的最大金額。

這個值是多少？根據我們的定義，它不多不少，正好就是 dp[i-1]。

dp[i-1] 這個值已經幫我們把「要不要偷第 i-1 間」這個問題的最佳解打包好了。我們現在不用再去管 i-1 到底有沒有被偷，我們只要知道，不偷 i 的話，我們的最佳財富就是 dp[i-1]。

選擇 2：【偷】第 i 間房子
如果我們決定 要偷 第 i 間，規則說我們就 不能偷 前一間 (i-1)。

所以，我們的總金額會是「第 i 間房子的錢 (nums[i])」加上「截至第 i-2 間為止，我們能拿到的最大金額」。

這個值就是 nums[i] + dp[i-2]。

```cpp
class Solution {
public:


    
    int rob(vector<int>& nums) {
        // 記憶化搜索  
        // 遞規+保存節點

        // int n= nums.size();
        // vector<int>dp(n,-1);

        // function<int(int)> dfs =
        // [&](int i)->int{
        //     if(i<0)return 0;
        //     // 計算過了
        //     if(dp[i]!=-1)return dp[i];
        //     dp[i] = max(dfs(i-1),dfs(i-2)+nums[i]);
        //     return dp[i];
        // };

        // return dfs(n-1);


        // 遞推
        int n = nums.size();
        vector<int>dp(n,0);

        if(n==1)return nums[0];
        dp[0]=nums[0];
        dp[1]=max(nums[0],nums[1]);
        
        for(int i=2;i<n;i++){
            dp[i] = max(dp[i-1] ,dp[i-2]+nums[i]);
        }
        return dp[n-1];
    }
};

```
