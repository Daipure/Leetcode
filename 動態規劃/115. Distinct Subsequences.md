---

**簡要回答**
題目是計算 `s` 中有多少個不同的子序列等於 `t`，用動態規劃 `dp[i][j]` 表示「`s` 前 i 個字元中，有多少種方式可以組成 `t` 前 j 個字元」。

---

**延伸回答**

1. **狀態定義**

   * `dp[i][j]`：表示 `s` 前 i 個字元（`s[0..i-1]`）中，有多少種不同的子序列可以組成 `t` 前 j 個字元（`t[0..j-1]`）。

2. **初始化**

   * 當 `j = 0` 時，`dp[i][0] = 1`，因為空字串是所有字串的子序列（唯一方法就是不選任何字元）。
   * 當 `i = 0` 且 `j > 0`，`dp[0][j] = 0`，因為空字串不可能組成非空字串。
   * 特別地 `dp[0][0] = 1`，空字串組成空字串的方法只有 1 種。

3. **狀態轉移公式**

   * 若 `s[i-1] == t[j-1]`：

     * 可以選擇用 `s[i-1]` 來匹配 `t[j-1]` → `dp[i-1][j-1]`
     * 或不使用 `s[i-1]` → `dp[i-1][j]`
     * 所以：

       ```
       dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
       ```
   * 若 `s[i-1] != t[j-1]`：

     * 只能不使用 `s[i-1]`，所以：

       ```
       dp[i][j] = dp[i-1][j]
       ```

4. **時間複雜度**

   * 共有 `O(|s| * |t|)` 個狀態，每個狀態轉移 O(1)，
     時間複雜度：`O(n * m)`，其中 `n = s.size()`，`m = t.size()`。
   * 空間複雜度：`O(n * m)`（可進一步優化為 O(m) 滾動陣列）。

---

**程式碼**

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));

        // 初始化
        for (int i = 0; i <= s.size(); i++) dp[i][0] = 1;
        dp[0][0] = 1;

        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};
```

---

