這段程式是 **LeetCode 583「Delete Operation for Two Strings」** 的一個常見 DP 解法，核心想法是：
用動態規劃計算把兩個字串變成相同所需刪除的最少步驟數。

---

## **簡要回答**

* **dp\[i]\[j]** 代表將 `word1` 前 **i** 個字元與 `word2` 前 **j** 個字元變成相同所需的最少刪除步數。
* 狀態轉移：

  * 若字元相等 → 不刪除，直接繼承 `dp[i-1][j-1]`。
  * 若字元不同 → 刪一邊的字元，取 `min(dp[i-1][j], dp[i][j-1]) + 1`。

---

## **延伸回答（流程 + 複雜度分析）**

### **流程說明**

1. **初始化**

   * `dp[i][0] = i` → 若第二個字串長度為 0，必須刪掉 `i` 個字元。
   * `dp[0][j] = j` → 若第一個字串長度為 0，必須刪掉 `j` 個字元。

2. **狀態轉移**

   * 如果 `word1[i-1] == word2[j-1]` → 不用刪除，`dp[i][j] = dp[i-1][j-1]`。
   * 否則 → 要刪除一邊的字元，
     `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1`。

3. **答案**
   `dp[word1.size()][word2.size()]` 即為最少刪除步驟數。

---

### **時間與空間複雜度**

* **時間複雜度**：`O(m * n)`
  m = `word1` 長度，n = `word2` 長度。
* **空間複雜度**：`O(m * n)`（可優化成 O(min(m, n))）。

---

## **程式碼**

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));

        // 初始化
        for(int i = 0; i <= m; i++) dp[i][0] = i;
        for(int j = 0; j <= n; j++) dp[0][j] = j;

        // 動態規劃
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if(word1[i-1] == word2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1;
            }
        }
        return dp[m][n];
    }
};
```

---

如果你要的話，我可以幫你整理一份 **LeetCode 583 的另一種 LCS（最長公共子序列）解法** 筆記，會更直觀，因為它直接用
`刪除次數 = m + n - 2 * LCS長度` 的公式。
這樣可以少掉一些思考負擔。
