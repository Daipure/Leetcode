---

### 題目：62. Unique Paths（唯一路徑）

---

### ✅ 簡要回答：

使用動態規劃，計算從左上角走到右下角，且只能向下或向右移動時，總共有幾種不同的走法。

---

### 📘 延伸回答：

#### 📌 題目描述：

你站在一個 `m x n` 的格子左上角 (0, 0)，只能往「**右**」或「**下**」走，每次一步。問你要走到右下角 (`m-1, n-1`) 總共有幾條**不同的路徑**？

---

#### 📌 狀態定義：

> `dp[i][j]` 表示走到格子 `(i, j)` 的所有不同路徑數。

---

#### 📌 初始條件：

* 第一列和第一欄的格子只能從一個方向走到（第一列只能從左邊來，第一欄只能從上面來）：

```cpp
dp[i][0] = 1  // 第一欄
dp[0][j] = 1  // 第一列
```

---

#### 📌 狀態轉移方程式：

```cpp
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
```

* 走到 `(i,j)` 的方法來自：

  * 上方 `dp[i - 1][j]`（從上往下）
  * 左方 `dp[i][j - 1]`（從左往右）

---

#### 🧠 複雜度分析：

* **時間複雜度**：`O(m * n)`，每個格子都走過一次。
* **空間複雜度**：`O(m * n)`，使用了二維陣列 `dp`。

---

### 💻 程式碼：

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));

        for (int i = 0; i < m; i++) dp[i][0] = 1;  // 初始化第一欄
        for (int j = 0; j < n; j++) dp[0][j] = 1;  // 初始化第一列

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  // 狀態轉移
            }
        }

        return dp[m - 1][n - 1];  // 回傳右下角的路徑數
    }
};
```
---
