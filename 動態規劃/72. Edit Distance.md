這段程式是 **LeetCode 72「Edit Distance」**（編輯距離）經典 DP 解法，與 583 的差別在於這裡允許 **插入、刪除、替換** 三種操作。
替代是dp[i][j]=dp[i-1][j-1] + 1 因為最後一個元素 s[i-1][j-1]需要1步驟替代 此時問題可視為dp[i-1][j-1]的子問題

---

## **簡要回答**

* **dp\[i]\[j]**：將 `word1` 前 **i** 個字元變成 `word2` 前 **j** 個字元的最少編輯步驟數。
* 狀態轉移：

  * 若字元相等 → `dp[i][j] = dp[i-1][j-1]`
  * 若字元不同 →
    `dp[i][j] = min(替換, 刪除, 插入) + 1`

    * **替換**：`dp[i-1][j-1] + 1`
    * **刪除**：`dp[i-1][j] + 1`
    * **插入**：`dp[i][j-1] + 1`

---

## **延伸回答（流程 + 複雜度分析）**

### **流程說明**

1. **初始化**

   * `dp[i][0] = i` → 把 `word1` 的前 i 個字刪掉
   * `dp[0][j] = j` → 把 `word2` 的前 j 個字插入

2. **狀態轉移**

   * 如果 `word1[i-1] == word2[j-1]`，不用編輯，直接 `dp[i][j] = dp[i-1][j-1]`。
   * 否則取三種操作最小值：

     * **替換** → `dp[i-1][j-1]`
     * **刪除**（刪掉 `word1[i-1]`）→ `dp[i-1][j]`
     * **插入**（在 `word1` 中插入 `word2[j-1]`）→ `dp[i][j-1]`
       再 `+1`。

3. **答案**
   `dp[word1.size()][word2.size()]` 即最少編輯步數。

---

### **時間與空間複雜度**

* **時間複雜度**：`O(m * n)`
* **空間複雜度**：`O(m * n)`（可壓縮成一維陣列）

---

## **程式碼**

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));

        // 初始化
        for(int i = 0; i <= m; i++) dp[i][0] = i;
        for(int j = 0; j <= n; j++) dp[0][j] = j;

        // 動態規劃
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if(word1[i-1] == word2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]}) + 1;
            }
        }
        return dp[m][n];
    }
};
```

---


