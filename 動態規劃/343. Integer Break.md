---

## ✅ 簡要回答：

這題是要將一個正整數 `n` 拆成兩個以上正整數之和，並使這些數字的乘積最大，回傳這個最大乘積。用 DP 方式記錄每個 `i` 對應的最大乘積。

---

## 🔍 延伸回答：

### 🧠 解題思路：

* 設 `dp[i]` 表示將整數 `i` 拆分後可得到的**最大乘積**。
* 我們考慮將 `i` 拆成 `j + (i - j)`，其中 `1 ≤ j < i`，有兩種情況：

  * 不繼續拆：`j * (i - j)`
  * 繼續拆：`j * dp[i - j]`
* 狀態轉移公式：

  ```
  dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
  ```

### 🔁 迴圈設計：

* 外層：`i` 從 `2` 開始到 `n`，表示要拆的數字。
* 內層：`j` 從 `1` 到 `i-1`，表示要拆掉的其中一個部分。

---

### ⏱️ 時間與空間複雜度：

* 時間複雜度：`O(n^2)`
* 空間複雜度：`O(n)`

---

## 🧾 程式碼：

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1, 0);
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
```

---
