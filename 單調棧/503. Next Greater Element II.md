我幫你整理成你平常的 LeetCode 筆記格式：

---

**簡要回答**
用單調遞減棧解決 **Next Greater Element II（環狀陣列版）**。
透過遍歷兩倍長度的陣列模擬環狀特性，棧內儲存索引，遇到更大元素就更新結果。

---

**延伸回答（流程與複雜度分析）**

1. **資料結構選擇**

   * **單調遞減棧（存索引）**：保持棧內元素對應的值遞減，用來快速找到下一個更大元素。
   * **result 陣列**：預設為 -1，表示沒有更大元素。

2. **流程**

   * 設 `n = nums.size()`。
   * 初始化結果陣列 `result` 為 -1，棧存索引（初始推入 `0`）。
   * 遍歷 `i` 從 `1` 到 `2n - 1`：

     1. **取環狀索引**：`idx = i % n`。
     2. 如果 `nums[idx] <= nums[sta.top()]` → 入棧 `idx`。
     3. 否則（找到更大元素）：

        * 不斷彈出棧頂，直到棧空或棧頂值 ≥ 當前值。
        * 對每個彈出的索引 `j`，更新 `result[j] = nums[idx]`。
        * 最後將 `idx` 入棧。
   * 因為是環狀陣列，遍歷長度為 `2n` 可以確保每個位置都能找到環狀之後的更大元素。

3. **複雜度分析**

   * **時間複雜度**：O(n)，每個索引最多進棧一次、出棧一次（雖然迴圈長度為 `2n`，但出棧與更新動作總次數仍 O(n)）。
   * **空間複雜度**：O(n)，用於棧與結果陣列。

---

**程式碼**

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n, -1);
        stack<int> sta; // 存索引
        sta.push(0);

        for (int i = 1; i < n * 2; i++) {
            int idx = i % n;
            if (nums[idx] <= nums[sta.top()]) {
                sta.push(idx);
            } else {
                while (!sta.empty() && nums[idx] > nums[sta.top()]) {
                    result[sta.top()] = nums[idx];
                    sta.pop();
                }
                sta.push(idx);
            }
        }
        return result;       
    }
};
```

---
