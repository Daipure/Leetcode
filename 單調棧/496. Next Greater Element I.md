我幫你整理成跟你平常一樣的 LeetCode 筆記格式：

---

**簡要回答**
用單調遞減棧搭配 `unordered_map` 儲存 `nums1` 中數字在結果陣列的索引位置，遍歷 `nums2` 時找到更大元素就更新對應的 `result` 值。

---

**延伸回答（流程與複雜度分析）**

1. **資料結構選擇**

   * **`unordered_map<int,int>`**：將 `nums1` 的元素映射到其在結果陣列中的索引，方便 O(1) 查詢更新位置。
   * **單調棧（存索引）**：保持棧內元素對應的數值遞減，方便找下一個更大元素。

2. **流程**

   * 初始化 `result` 為 -1（假設沒有下一個更大元素）。
   * 建立 `map`，將 `nums1` 的值對應到 `result` 的索引位置。
   * 遍歷 `nums2`：

     1. 如果 `nums2[i] <= nums2[sta.top()]` → 入棧索引 `i`。
     2. 否則（找到更大元素）：

        * 不斷彈出棧頂，直到棧空或棧頂元素值 ≥ 當前值。
        * 如果棧頂值存在於 `nums1`（用 `map.count()` 查），更新 `result[map[該值]] = 當前值`。
        * 最後將 `i` 入棧。

3. **複雜度分析**

   * **時間複雜度**：O(n)（每個元素最多進棧一次、出棧一次，map 查詢 O(1)）
   * **空間複雜度**：O(n)（棧 + map + 結果陣列）

---

**程式碼**

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        vector<int> result(nums1.size(), -1);
        unordered_map<int, int> map; // nums1值 -> result索引
        for (int i = 0; i < nums1.size(); i++) 
            map[nums1[i]] = i;

        stack<int> sta; // 存索引
        sta.push(0);

        for (int i = 1; i < nums2.size(); i++) {
            if (nums2[i] <= nums2[sta.top()]) {
                sta.push(i);
            } else {
                while (!sta.empty() && nums2[i] > nums2[sta.top()]) {
                    if (map.count(nums2[sta.top()])) {
                        result[map[nums2[sta.top()]]] = nums2[i];
                    }
                    sta.pop();
                }
                sta.push(i);
            }
        }
        return result;
    }
};
```

---

如果你願意，我可以幫你畫**nums2 遍歷時棧內容變化流程圖**，像教 dailyTemperatures 那樣，讓你一次看懂每一步為什麼出棧與更新。
要我幫你畫嗎？
