我幫你整理成你平常的 LeetCode 筆記格式：

---

**簡要回答**
利用單調遞減棧（存索引）來找下一個比當前溫度高的天數差。當新元素溫度比棧頂索引對應溫度大時，不斷彈出並計算距離，否則將當前索引入棧。

---

**延伸回答（流程與複雜度分析）**

1. **資料結構選擇**

   * 使用 `stack<int>` 儲存溫度的 **索引**，而不是直接存溫度，方便計算天數差。
   * 棧內保持**遞減溫度**順序（索引對應的溫度遞減）。

2. **流程**

   * 初始化 `result` 為全 0（預設沒有更高溫的天數差）。
   * 從左到右遍歷 `temperatures`：

     1. **比較當前溫度與棧頂溫度**

        * 如果當前溫度 > 棧頂溫度，代表找到了棧頂對應日期的「下一個更高溫的日子」。
        * 彈出棧頂索引 `index`，計算 `i - index` 並存入 `result[index]`。
     2. 重複比較直到棧為空或棧頂溫度 >= 當前溫度。
     3. 將當前索引 `i` 入棧。
   * 遍歷結束後，棧中剩下的索引都是沒有更高溫日子的，保持 `0`。

3. **複雜度分析**

   * **時間複雜度**：O(n)，每個元素最多進棧一次、出棧一次。
   * **空間複雜度**：O(n)，用於儲存棧與結果陣列。

---

**程式碼**

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        if (temperatures.size() == 1) return {0};

        vector<int> result(temperatures.size(), 0);
        stack<int> sta; // 儲存索引
        sta.push(0);

        for (int i = 1; i < temperatures.size(); i++) {
            while (!sta.empty() && temperatures[i] > temperatures[sta.top()]) {
                int index = sta.top();
                sta.pop();
                result[index] = i - index; // 計算天數差
            }
            sta.push(i); // 當前索引入棧
        }
        return result;
    }
};
```

---

如果你要的話，我可以幫你畫**單調棧的推進過程圖**，看每一步棧怎麼變化，會更直觀。
你要我幫你畫嗎？
