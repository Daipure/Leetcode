
---

**簡要回答**
用 DFS 遍歷島嶼，計算每個連通區塊的面積，取最大值。

---

**延伸回答（流程與複雜度分析）**

1. **初始化**

   * 建立 `visited` 陣列記錄是否訪問過該格。
   * `result` 存最大島嶼面積。
2. **遍歷整張地圖**

   * 遇到尚未訪問的陸地（`grid[i][j] == 1` 且 `visited == false`），以該點為起點 DFS。
3. **DFS 探索**

   * 從當前座標向四個方向擴展，遇到符合條件的陸地就遞迴繼續探索並累積計數。
4. **更新最大值**

   * 每完成一次 DFS，就更新最大面積 `result`。
5. **回傳結果**

   * 最終輸出最大島嶼面積。

**時間複雜度**：

* 每個格子最多訪問一次 → `O(m*n)`
  **空間複雜度**：
* `visited` 陣列 `O(m*n)` + DFS 遞迴棧最深 `O(m*n)`

---

**程式碼**

```cpp
class Solution {
public:
    int result = 0;   // 最大面積
    int count = 1;    // 當前島嶼面積
    int dir[4][2] = { {0,1},{1,0},{-1,0},{0,-1} };

    void dfs(vector<vector<int>>& grid, int x, int y, vector<vector<bool>>& visited) {
        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            // 邊界檢查
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) {
                continue;
            }
            // 陸地且沒訪問過
            if (grid[nextx][nexty] == 1 && !visited[nextx][nexty]) {
                count++;
                visited[nextx][nexty] = true;
                dfs(grid, nextx, nexty, visited);
            }
        }
    }

    int maxAreaOfIsland(vector<vector<int>>& grid) {
        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    count = 1;
                    visited[i][j] = true;
                    dfs(grid, i, j, visited);
                    result = max(result, count);
                }
            }
        }
        return result;
    }
};
```

---
