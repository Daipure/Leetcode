
---

## LeetCode 827. Making A Large Island

### 簡要回答

題目要求：在一個由 `0`（海洋）和 `1`（陸地）組成的網格中，允許把**最多一個 `0` 變成 `1`**，求能形成的最大島嶼面積。

解法：

1. 先用 DFS/BFS 給每個島嶼編號，並記錄其面積。
2. 再遍歷每個 `0`，嘗試變成 `1`，並計算它相鄰的不同島嶼面積總和。
3. 答案取最大值。

---

### 延伸回答

1. **核心思路**

   * 如果直接對每個 `0` 嘗試「變 1」然後 DFS/BFS 求島嶼大小，會超時（O(m²n²)）。
   * 正確作法：

     * 先將每個島嶼用唯一編號（從 2 開始）標記，並存進 `hash[mark] = 面積`。
     * 遍歷每個 `0`，看它相鄰的格子是哪些島嶼，避免重複計算，將面積加總再 +1。

2. **流程**

   * DFS/BFS 遍歷陸地，編號並計算面積 → 存進 `hash`。
   * 掃描所有格子，若為 `0`：

     * 用 `unordered_set` 收集鄰居島嶼編號（避免重複）。
     * 把這些島嶼的面積加總，再 +1（表示把自己變成陸地）。
     * 更新最大值。
   * 還要考慮整個地圖已全是陸地的情況，這時最大值就是最大島嶼的面積。

3. **複雜度分析**

   * **時間複雜度**：O(m\*n)，每個格子訪問固定次數。
   * **空間複雜度**：O(m\*n)，存 visited 與 hash。

---

### 程式碼

```cpp
class Solution {
public:
    int count = 0;
    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
    unordered_map<int,int> hash; // island_id -> size

    void dfs(vector<vector<int>>& grid, int x, int y, vector<vector<bool>>& visited, int &mark) {
        if (visited[x][y] || grid[x][y] == 0) return;
        visited[x][y] = true;
        count++;
        grid[x][y] = mark; // 用島嶼編號標記

        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size())
                continue;
            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {
                dfs(grid, nextx, nexty, visited, mark);
            }
        }
    }

    int largestIsland(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        int mark = 2;
        vector<vector<bool>> visited(m, vector<bool>(n, false));

        // Step 1: 給島嶼編號並記錄大小
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (!visited[i][j] && grid[i][j] == 1) {
                    count = 0;
                    dfs(grid, i, j, visited, mark);
                    hash[mark] = count;
                    mark++;
                }
            }
        }

        // Step 2: 嘗試把每個 0 變 1
        int result = 0;
        for (auto it : hash) {
            result = max(result, it.second); // 初始最大島嶼
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    unordered_set<int> s;
                    int scount = 1; // 把自己變成 1
                    for (int k = 0; k < 4; k++) {
                        int nextx = i + dir[k][0];
                        int nexty = j + dir[k][1];
                        if (nextx < 0 || nextx >= m || nexty < 0 || nexty >= n)
                            continue;
                        if (!s.count(grid[nextx][nexty])) {
                            scount += hash[grid[nextx][nexty]];
                            s.insert(grid[nextx][nexty]);
                        }
                    }
                    result = max(result, scount);
                }
            }
        }

        return result;
    }
};
```

---

