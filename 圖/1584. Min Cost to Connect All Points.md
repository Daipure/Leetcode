prim演算法
找出最小生成樹
找出距離樹中節點距離節點最小的且該節點不在樹中
加入生成樹
更新樹銓重


```cpp

class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        // 將不在加入樹中的節點 選擇距離數中距離最小的
        // 加入樹中
        // 更新mindist

        int n = points.size();
        vector<vector<int>>graph(n,vector<int>(n,0));

        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(i!=j){
                    int node1_x = points[i][0];
                    int node1_y = points[i][1];
                    int node2_x = points[j][0];
                    int node2_y = points[j][1];
                    graph[i][j]= abs(node1_x-node2_x)+abs(node1_y-node2_y);
                }
            }
        }

        vector<bool>is_tree(n,false);
        vector<int>min_dist(n,INT_MAX);

        // 更新n-1次 // 找到距離最小的
        for(int i=1;i<n;i++){
            int cur_MIN = INT_MAX;
            int cur = 0;
            for(int j=0;j<n;j++){
                // 找出最小的
                if(is_tree[j]==false && min_dist[j]<cur_MIN){
                    cur_MIN = min_dist[j];
                    cur = j;
                }
            }
            // 加入tree
            is_tree[cur]=true;

            // 更新權重
            for(int j=0;j<n;j++){
                if(is_tree[j]==false && graph[cur][j] < min_dist[j]){
                    min_dist[j] = graph[cur][j];
                }
            }
        }

        // 統計cost
        int cost = 0;
        for(int i=1;i<n;i++){
            cost+=min_dist[i];
        }
        return cost;
    }
};

```
