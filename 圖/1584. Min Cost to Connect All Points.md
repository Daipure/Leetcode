prim演算法
找出最小生成樹
找出距離樹中節點距離節點最小的且該節點不在樹中
加入生成樹
更新樹銓重

kruskal最小的邊優先

```cpp

class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        // 將不在加入樹中的節點 選擇距離數中距離最小的
        // 加入樹中
        // 更新mindist

        int n = points.size();
        vector<vector<int>>graph(n,vector<int>(n,0));

        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(i!=j){
                    int node1_x = points[i][0];
                    int node1_y = points[i][1];
                    int node2_x = points[j][0];
                    int node2_y = points[j][1];
                    graph[i][j]= abs(node1_x-node2_x)+abs(node1_y-node2_y);
                }
            }
        }

        vector<bool>is_tree(n,false);
        vector<int>min_dist(n,INT_MAX);

        // 更新n-1次 // 找到距離最小的
        for(int i=1;i<n;i++){
            int cur_MIN = INT_MAX;
            int cur = 0;
            for(int j=0;j<n;j++){
                // 找出最小的
                if(is_tree[j]==false && min_dist[j]<cur_MIN){
                    cur_MIN = min_dist[j];
                    cur = j;
                }
            }
            // 加入tree
            is_tree[cur]=true;

            // 更新權重
            for(int j=0;j<n;j++){
                if(is_tree[j]==false && graph[cur][j] < min_dist[j]){
                    min_dist[j] = graph[cur][j];
                }
            }
        }

        // 統計cost
        int cost = 0;
        for(int i=1;i<n;i++){
            cost+=min_dist[i];
        }
        return cost;
    }
};

```

```cpp

class Solution {
public:

    struct edge{
        int u;
        int v;
        int val;
    };
    vector<int>father;

    void init(int n){
        father.resize(n);
        for(int i=0;i<n;i++){
            father[i]=i;
        }
    }

    void join(int u,int v){
        if(find(u)==find(v))return;
        int rootu = find(u);
        int rootv = find(v);
        father[rootu]=rootv;
    }   

    int find(int u){
        if(father[u]==u)return u;
        father[u] = find(father[u]);
        return father[u];
    }

    int minCostConnectPoints(vector<vector<int>>& points) {
        int n = points.size();
        init(n);

        vector<edge>edges;

        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(i!=j){
                    int x1 = points[i][0];
                    int y1 = points[i][1];
                    int x2 = points[j][0];
                    int y2 = points[j][1];
                    int val = abs(x1-x2)+abs(y1-y2);
                    edges.push_back({i,j,val});
                }
            }
        }

        // 排序
        sort(edges.begin(),edges.end(),[](edge &a,edge &b){
            return a.val<b.val;
        });

        // 邊小的加入

        int res = 0;
        for(auto edge :edges){
            if(find(edge.u) != find(edge.v)){
                join(edge.u,edge.v);
                res+=edge.val;
            }
        }
        return res;
    }
};

```
