將編存成連接列表
對source 進行dfs 如果可以便利到終點return true

```cpp

class Solution {
public:

    
    void dfs(int source,vector<vector<int>>& adj,vector<bool> &visited){
        if(visited[source])return;
        visited[source]=true;

        vector<int>nodes = adj[source];
        for(int node: nodes){
            if (!visited[node]) {
                dfs(node, adj, visited);
            }
        }
    }
    
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        // 如果起點和終點相同，路徑顯然存在
        if (source == destination) {
            return true;
        }

        // 1. 建立鄰接表 (Adjacency List)
        vector<vector<int>> adj(n);
        for (const auto& edge : edges) {
            int u = edge[0];
            int v = edge[1];
            // 因為是無向圖，所以要雙向都加入
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        
        // 2. 建立 visited 陣列，記錄節點是否被訪問過
        vector<bool> visited(n, false);
        
        // 3. 從 source 開始進行 DFS
        dfs(source, adj, visited);
        
        // 4. DFS 結束後，檢查 destination 是否被訪問過
        // 如果被訪問過，代表 source 和 destination 是連通的
        return visited[destination];
    }
};

```
