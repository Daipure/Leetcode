拓樸排序
使用BFS 將入度為0的加入que中 與之相連的入度-1 


```cpp

class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 要先修 bi 才能 修ai
        // 拓樸排序 判斷結果集是否等於 numCourses

        vector<int>res;
        queue<int>que;
        unordered_map<int,vector<int>>umap;
        vector<int>indegree(numCourses,0);

        // 找到入度為0的 加入que中與其相連的節點入度-1，使用BFS

        for(int i=0;i<prerequisites.size();i++){
            int a = prerequisites[i][0];
            int b = prerequisites[i][1];
            indegree[a]++;
            umap[b].push_back(a);
        } 
        
        for(int i=0;i<indegree.size();i++){
            if(indegree[i]==0)que.push(i);
        }

        while(!que.empty()){
            int cur_node = que.front();
            res.push_back(cur_node);
            que.pop();
            // 與其相連的節點入度-1
            vector<int>notes = umap[cur_node];
            for(auto node: notes){
                indegree[node]--;
                if(indegree[node]==0){
                    que.push(node);
                }
            }
        }

        return res.size()==numCourses?true:false;
    }
};

```
