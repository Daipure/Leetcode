---

**簡要回答**
利用 DFS 或 BFS 遍歷整張地圖，遇到未訪問的陸地（'1'）就將其整個連通區域標記為已訪問，並計數一次島嶼。

---

**延伸回答**

**流程：**

1. 建立 `visited` 二維陣列，記錄每個格子是否已訪問。
2. 雙層迴圈遍歷地圖：

   * 若當前格子是 `'1'` 且未訪問，島嶼數 `result++`。
   * 使用 **DFS** 或 **BFS** 把與該格子相連的所有 `'1'` 標記為已訪問。
3. 最後 `result` 即為島嶼數量。

**DFS 與 BFS 差異：**

* DFS：遞迴深入，適合小地圖（遞迴深度可能過深造成棧溢位）。
* BFS：使用佇列逐層擴展，適合避免遞迴過深的情況。

**時間複雜度**：

* **O(m × n)**，每個格子最多訪問一次。

**空間複雜度**：

* `visited` 需要 **O(m × n)**，DFS 還需要遞迴棧空間；BFS 需要佇列空間（最壞情況 O(m × n)）。

---

**程式碼（DFS + BFS）**

```cpp
class Solution {
public:
    int result = 0;
    int dir[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};

    // DFS 寫法
    void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];

            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;
            if (!visited[nextx][nexty] && grid[nextx][nexty] == '1') {
                visited[nextx][nexty] = true;
                dfs(grid, visited, nextx, nexty);
            }
        }
    }

    // BFS 寫法
    void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
        queue<pair<int,int>> que;
        que.push({x, y});

        while (!que.empty()) {
            auto [curx, cury] = que.front();
            que.pop();

            for (int i = 0; i < 4; i++) {
                int nextx = curx + dir[i][0];
                int nexty = cury + dir[i][1];

                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;
                if (!visited[nextx][nexty] && grid[nextx][nexty] == '1') {
                    visited[nextx][nexty] = true;
                    que.push({nextx, nexty});
                }
            }
        }
    }

    int numIslands(vector<vector<char>>& grid) {
        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));

        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (!visited[i][j] && grid[i][j] == '1') {
                    result++;
                    visited[i][j] = true;
                    // 兩種方式擇一：
                    // dfs(grid, visited, i, j);
                    bfs(grid, visited, i, j);
                }
            }
        }
        return result;
    }
};
```

---


