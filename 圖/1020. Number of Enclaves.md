
---

**簡要回答**
用 DFS 把邊界可到達的陸地（1）全部淹沒成海洋（0），最後統計剩下的 1 即為被封閉的陸地格數。

---

**延伸回答（流程與複雜度分析）**

1. **觀察問題**

   * 被封閉的陸地必定不能連到邊界。
   * 如果從邊界開始 DFS，所有能到的陸地都不是封閉的。
2. **解法流程**

   1. 從四條邊界上所有格子出發，對值為 `1` 的格子進行 DFS，將所有相連的格子設為 `0`。
   2. 遍歷整張地圖，統計剩下的 `1` 數量。
3. **DFS 遞迴細節**

   * 遇到陸地（`1`）才繼續搜尋，並將其標記為海洋（`0`）。
   * 四個方向搜尋，注意邊界檢查。
4. **複雜度分析**

   * **時間複雜度**：`O(m*n)`（每格最多訪問一次）
   * **空間複雜度**：遞迴棧最深 `O(m*n)`（最壞情況全部是陸地）

---

**程式碼**

```cpp
class Solution {
public:
    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

    void dfs(vector<vector<int>>& grid, int x, int y) {
        if (grid[x][y] == 0) return; // 已是海洋
        grid[x][y] = 0;               // 淹沒該格
        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;
            if (grid[nextx][nexty] == 1) {
                dfs(grid, nextx, nexty);
            }
        }
    }

    int numEnclaves(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        // 從四條邊界淹沒可到的陸地
        for (int i = 0; i < m; i++) {
            dfs(grid, i, 0);
            dfs(grid, i, n - 1);
        }
        for (int j = 0; j < n; j++) {
            dfs(grid, 0, j);
            dfs(grid, m - 1, j);
        }
        // 統計剩下的陸地數量
        int result = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                result += grid[i][j];
            }
        }
        return result;
    }
};
```

---
