
---

**簡要回答**
這題是 LeetCode 797「所有可能的路徑」，用 DFS 回溯法，從節點 0 出發，走訪所有可能到達終點節點 (n-1) 的路徑，並收集結果。
容易錯的地方: 使用雙重迴圈 忽略了遞迴特性
---

**延伸回答**
**解題思路**：

1. 使用 `path` 紀錄當前路徑，`result` 紀錄所有路徑。
2. 從節點 0 開始，先將 0 加入 `path`。
3. 在 DFS 中，如果當前節點 `x` 是終點 `(n-1)`，就把 `path` 加入 `result`。
4. 否則遍歷 `graph[x]` 所有相鄰節點，遞迴往下走，並在回溯時移除最後一個節點 (`pop_back`)。

**流程**：

* 起點 `0` → 將 `0` 加入 path
* 對每個相鄰節點遞迴 DFS
* 抵達終點時儲存該路徑
* 回溯到上一層繼續探索其他路徑

**時間複雜度**：

* 最壞情況下是指數級 $O(2^n)$，因為可能存在大量不同的路徑。
* 空間複雜度 $O(n)$，主要來自遞迴深度與 `path` 暫存空間。

---

**程式碼**

```cpp
class Solution {
public:
    vector<vector<int>> result; // 紀錄所有路徑
    vector<int> path;           // 當前路徑

    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        path.push_back(0); // 起點加入路徑
        dfs(graph, 0, graph.size());
        return result;
    }

    void dfs(vector<vector<int>>& graph, int x, int n) {
        if (x == n - 1) { // 到達終點
            result.push_back(path);
            return;
        }
        for (int i = 0; i < graph[x].size(); i++) {
            path.push_back(graph[x][i]);       // 選擇節點
            dfs(graph, graph[x][i], n);        // 遞迴探索
            path.pop_back();                   // 回溯
        }
    }
};
```

---

