// 藉由旋轉陣列得特性 使用中間值與最左值比 如果大於 代表是遞增的 再利用目標值跟最左值和中間值去比較

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        
        // 使用二分搜尋 判斷要去哪一段尋找
        // target跟middle值比較
        // middle跟左值比較 如果大於左值代表是遞增
        
        int l = 0;
        int r = nums.size()-1;

        // 左閉右閉
        while(l <= r){
            int m = (l+r)/2;
            if(nums[m] == target) return m;

            // 遞增的
            if(nums[m]>=nums[l]){
                // 往左找
                if(target <nums[m] && target>= nums[l]){
                    r = m-1;
                }
                else{
                    l=m+1;
                }
            }
            // 不是遞增
            // nums[m]>=nums[l] 最小值在左邊 右邊是遞增
            // 在已知右邊是遞增 如果target比中間大起比最右的小 要去右邊找
            else{
                if(target>nums[m] && target <= nums[r]){
                    l = m+1;
                }
                else{
                    r = m-1;
                }
            }
            
        }
        return -1;
    }
};
```
