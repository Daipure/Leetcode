1. 解題框架與脈絡
這個問題可以被想像成：在一個由字元組成的迷宮中，從任意一點出發，是否能「剛好」走出一個指定的路徑（word），且走過的格子不能重複踩。

框架：DFS + Backtracking
DFS (深度優先搜尋)：我們需要尋找一條「路徑」。DFS 是一種「一條路走到黑」的搜尋策略，非常適合用來探測是否存在這樣一條完整的路徑。

Backtracking (回溯法)：這是整個解法的核心。由於我們不確定哪條路徑是對的，我們必須進行「嘗試」。

選擇 (Choose)：當我們踏上一個格子 (x, y)，我們就「選擇」它作為路徑的一部分，並將其標記為 visited[x][y] = true，防止這條路徑再踩到它。

探索 (Explore)：我們遞迴地去探索該格子的所有「有效」鄰居。

撤銷 (Unchoose/Backtrack)：當我們從 (x, y) 出發的所有鄰居路徑都探索完畢（無論成功或失敗），我們都必須撤銷我們的選擇，即 visited[x][y] = false。這一步至關重要，因為它釋放了 (x, y) 這個格子
，讓其他的「起始路徑」（例如從另一個點出發的搜尋）有機會使用它。

```cpp

class Solution {
public:

    string s;
    int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
    bool flag = false;

    // 控制是word 第幾個 以及目前是board第幾個
    void backtarcking(vector<vector<char>>& board, string word,int word_index,vector<vector<bool>>&visited,int x,int y){
        
        if(word_index == word.size()){
            flag = true;
            return;
        }

        visited[x][y]=true;

        for(int i=0;i<4;i++){

            int nextx = x+dir[i][0];
            int nexty = y+dir[i][1];

            if(nextx<0||nextx>=board.size()||nexty<0||nexty>=board[0].size())continue;
            if(board[nextx][nexty]!=word[word_index] || visited[nextx][nexty]==true )continue;

            backtarcking(board,word,word_index+1,visited,nextx,nexty);
            if(flag==true)return;
            
        }
        visited[x][y]=false;
    }

    bool exist(vector<vector<char>>& board, string word) {
        vector<vector<bool>>visited(board.size(),vector<bool>(board[0].size(),false));

        // 直到ij 等於 word[i]
        for(int i=0;i<board.size();i++){
            for(int j=0;j<board[0].size();j++){        
                if(board[i][j]==word[0]){
                    backtarcking(board,word,1,visited,i,j);
                }    
                
            }
        }
        if(flag==true)return true;
        return false;

    }
};
```
