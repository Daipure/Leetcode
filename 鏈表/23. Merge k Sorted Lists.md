暴力解:把每個node 都存起來 然後排序後恢復成練表

練表解: 22合併


```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // ListNode* mergeKLists(vector<ListNode*>& lists) {
    //     // 暴力 : 把每個node 都存起來 然後排序
    //     vector<int> nodes;

    //     for( ListNode* list : lists){
    //         while(list){
    //             nodes.push_back(list->val);
    //             list=list->next;
    //         }
    //     }
    //     sort(nodes.begin(),nodes.end());

    //     // 拼接回練表
    //     ListNode* res = new ListNode(0);
    //     ListNode *cur = res;

    //     for(int node:nodes){
    //         cur->next= new ListNode(node);
    //         cur=cur->next;
    //     }
    //     return res->next;
    // }

    ListNode* merge(ListNode* fir ,ListNode* sec){
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;

        while(fir && sec){
            if(fir->val <= sec->val){
                cur->next=fir;
                fir=fir->next;
            }
            else{
                cur->next=sec;
                sec=sec->next;
            }
            cur = cur->next;
        }

        if(fir){
            cur->next = fir;
        }
        else{
            cur->next = sec;
        }
        return dummy->next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // 22合併 回傳merge後的
        if(lists.size()==0)return NULL;

        for(int i=0;i<lists.size()-1;i++){
            lists[i+1] = merge(lists[i],lists[i+1]);
        }

        return lists[lists.size()-1] ;
    }
};
```
